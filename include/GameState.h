#pragma once
#include <memory>
#include <vector>

#include "CardEntity.h"

// Thoughts:
// - each card can take the state object in and return an updated version
// - each card function is added as a reference to a vector
// - state is generated by taking the starting state then applying each card in
// sequence
// - each time a card is added we recalculate then cache the current state for
// rendering

class GameState {
  std::vector<CardEntity*> selectedCards = {};
  int complexity = 10;
  int time = 10;
  int price = 10;
  int appeal = 1;
  int quality = 1;
  int progress = 0;

 public:
  GameState() {}
  ~GameState() {
    // FIXME: adding this causes malloc errors on exit for some reason...
    // for (auto card : selectedCards) {
    //   delete card;
    // }
    selectedCards.clear();
  }
  void addCard(CardEntity* card) {
    selectedCards.push_back(new CardEntity(*card));
    // TODO: apply card effects to current game or studio state
  }
  void applyModifier(CardEntity* card) {
    // TODO: apply studio modifiers to new game
  }
  bool gameComplete() { return progress >= 100; }
};